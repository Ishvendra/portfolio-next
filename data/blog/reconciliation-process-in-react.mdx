---
id: reconciliation-process-in-react
title: React's Reconciliation
subTitle: A Deep Dive into the Engine Room 🏎️
date: '2025-08-26'
readingTime: '12'
tags: ['react', 'reconciliation']
alsoRead:
  [
    'how-big-tech-checks-your-username-instantly',
    'partial-pre-rendering-process-in-next-js',
  ]
---

> **TL;DR:** React's magic lies in its ability to efficiently update the UI. This isn't achieved by directly manipulating the browser DOM, but through a sophisticated process called Reconciliation. It involves the Virtual DOM, a diffing algorithm, and strategic updates to minimize costly direct DOM operations. Understanding this process is key to writing performant React applications.

If you've spent any time with React, you've likely marveled at how smoothly it updates your user interface. You change some state, and _poof!_ – the UI magically reflects those changes without a full page reload or the clunkiness of direct DOM manipulation. It feels like magic, doesn't it?

For years, I used React without fully grasping _how_ it achieved this feat. I knew it had something to do with a "Virtual DOM" and "diffing," but the specifics remained a hazy black box. This lack of understanding often led to confusion when debugging performance issues or trying to optimize my components.

That's why I decided to dive deep. And what I uncovered is a beautifully engineered system designed for efficiency and developer experience. In this comprehensive guide, we're going to pull back the curtain and explore the React Reconciliation process from the ground up. By the end, you'll not only understand _what_ it does but _how_ it does it, empowering you to write more performant and robust React applications.

## Table of Contents

1. **The Problem with Direct DOM Manipulation**
2. **Enter the Virtual DOM: React's Master Plan**
3. **What Exactly is Reconciliation?**
4. **The Diffing Algorithm: Comparing Apples to Apples (and Oranges)**

   - Comparing Element Types
   - Key Prop: The Secret Weapon for Lists
   - Comparing Attributes and Props
   - Recursing on Children

5. **React Fiber: The Modern Reconciler (A Quick Peek)**
6. **Phases of React's Work: Render vs. Commit**
7. **Optimizing Reconciliation: Practical Tips**

   - Memoization (`React.memo`, `useMemo`, `useCallback`)
   - Conditional Rendering
   - The Power of `key` Props

8. **Conclusion: Beyond the Magic**

---

## 1. The Problem with Direct DOM Manipulation

Before we appreciate React's solution, let's understand the problem it solves. Imagine a typical web application without a framework like React. When you need to update the UI – say, change the text of an element or add a new list item – you'd directly interact with the browser's Document Object Model (DOM) using vanilla JavaScript.

JavaScript

```
// Example of direct DOM manipulation
const button = document.getElementById('myButton');
const list = document.getElementById('myList');

// Adding a new list item
function addItem(text) {
  const newItem = document.createElement('li');
  newItem.textContent = text;
  list.appendChild(newItem);
}

// Changing button text
function updateButtonText(newText) {
  button.textContent = newText;
}

// Imagine needing to do this for every small change,
// especially in a complex, dynamic UI.
```

While seemingly straightforward for small, static websites, this approach quickly becomes a nightmare in complex, interactive applications:

1. **Performance Bottleneck:** Each direct DOM manipulation is relatively slow. The browser has to recalculate layouts, repaint pixels, and reflow elements. Frequent, unoptimized updates can lead to jank and a poor user experience.
2. **Complexity:** Tracking the current state of the UI and deciding _what_ to update, _when_, and _how_ becomes incredibly complex. You, the developer, are responsible for imperatively managing every single change.
3. **Error-Prone:** It's easy to introduce bugs, memory leaks, or inconsistent UI states when manually managing the DOM.

This is where libraries like React step in, offering a declarative approach to UI development. You tell React _what_ the UI should look like based on your data, and React figures out _how_ to make that happen efficiently.

---

## 2. Enter the Virtual DOM: React's Master Plan

To sidestep the direct DOM manipulation problem, React introduced a brilliant concept: the **Virtual DOM**.

Think of the browser's DOM as a massive, heavy instruction manual that the browser has to read and act upon every time you want to make a change. Now imagine if you had a lightweight, rough draft version of that manual – easy to scribble on, quick to compare with previous drafts, and only when you're satisfied with your changes do you then write out the final, updated pages for the heavy manual.

That's essentially what the Virtual DOM is. It's a **lightweight, in-memory representation of the actual DOM**. It's just a plain JavaScript object (or a tree of objects) that mirrors the structure and properties of the browser's DOM.

When you write a React component, you're not directly creating DOM elements. You're describing what your UI _should_ look like using JSX. This JSX then gets compiled into React "elements" (JavaScript objects), which form the Virtual DOM tree.

```Javascript
// Your React component
function MyComponent({ count }) {
  return (
    <div>
      <h1>Current Count: {count}</h1>
      <button>Increment</button>
    </div>
  );
}

// React internally represents this as a tree of JavaScript objects:
// {
//   type: 'div',
//   props: { children: [
//     { type: 'h1', props: { children: `Current Count: ${count}` } },
//     { type: 'button', props: { children: 'Increment' } }
//   ]}
// }
```

React maintains two Virtual DOM trees:

1. **The current Virtual DOM:** Represents the UI as it currently looks on the screen.
2. **The new Virtual DOM:** Represents the UI as it _should_ look after a state or prop change.

This is the foundation for React's efficiency. Instead of updating the real DOM directly, React updates its Virtual DOM, compares the two versions, and then figures out the absolute minimum changes needed for the real DOM.

---

## 3. What Exactly is Reconciliation?

Reconciliation is the process by which React updates the browser's DOM to match the latest state of your components. It's the "diffing" phase where React compares the **new Virtual DOM tree** (generated from the latest `render()` output) with the **previous Virtual DOM tree** (representing the UI before the update).

This process answers a crucial question: "What has changed, and what's the most efficient way to apply these changes to the actual browser DOM?"

Here’s a simplified breakdown of the Reconciliation flow:

1. **State/Props Change:** Something triggers an update – `setState()`, `useState()` hook, new props from a parent, or `forceUpdate()`.
2. **Re-render:** The component's `render()` method (or functional component body) is called again. This generates a **new Virtual DOM tree** (a new set of React elements).
3. **Diffing:** React's Reconciliation algorithm compares this new Virtual DOM tree with the previous Virtual DOM tree.
4. **Batching Updates:** React collects all the differences (the "diff") into a queue.
5. **DOM Update:** React then applies these batched differences to the _actual_ browser DOM in the most efficient way possible, typically in a single go to minimize reflows and repaints.

This entire process is what we call **Reconciliation**. It's the core mechanism that allows React to provide its declarative, high-performance UI updates.

---

## 4. The Diffing Algorithm: Comparing Apples to Apples (and Oranges)

At the heart of Reconciliation is React's "diffing algorithm." This algorithm is what makes the comparison between the old and new Virtual DOM trees incredibly fast, largely due to two key assumptions that React makes:

1. **Two elements of different types will produce different trees.**
2. **The developer can hint at which child elements may be stable across different renders with a `key` prop.**

Let's break down how this algorithm works through different scenarios.

### A. Comparing Element Types

When React compares two elements, it first checks their `type`.

- **Different Types:** If the element types are different (e.g., `<div>` changes to `<span>`, or a `<MyComponent>` changes to `<AnotherComponent>`), React will tear down the old component/element and build the new one from scratch.

  - The old DOM node is destroyed.
  - Its children are unmounted.
  - The new component/element is mounted, and its entire subtree is built.
  - This is a destructive change, as React assumes entirely different logic.
    JavaScript

  ```Javascript
  // Initial render
  <MyComponent /> // Renders a <div>

  // Next render, if MyComponent now renders a <span> due to some internal logic,
  // or if the parent conditionally renders <MyComponent> vs <AnotherComponent>
  <AnotherComponent /> // Renders a <span>

  // React will destroy the <div> subtree and create the <span> subtree from scratch.
  ```

- **Same Types:** If the element types are the same (e.g., `<div>` remains a `<div>`, or `<MyComponent>` remains a `<MyComponent>`), React preserves the underlying DOM node. It then looks at the attributes (props) of the element.

---

### B. Key Prop: The Secret Weapon for Lists

This is perhaps one of the most crucial parts of the diffing algorithm, especially for rendering lists. When an element has children, React iterates over them, comparing the old children with the new children.

Consider a list of items:

JavaScript

```Javascript
// Initial render
<ul>
  <li>First</li>
  <li>Second</li>
</ul>

// New render, with an item inserted at the beginning
<ul>
  <li>Zero</li>
  <li>First</li>
  <li>Second</li>
</ul>
```

Without a `key` prop, React would naively compare `<li>First</li>` from the old list with `<li>Zero</li>` from the new list. It would then see `<li>Second</li>` vs `<li>First</li>`, and so on. It would likely assume that the first element changed its content, the second changed its content, and a new third element was added. This leads to inefficient re-rendering of elements that haven't actually changed.

This is where the `key` prop comes in. A `key` is a special string attribute you need to include when creating lists of elements. React uses `key`s to identify which items have changed, are added, or are removed.

JavaScript

```Javascript
// With keys
<ul>
  <li key="zero">Zero</li>    {/* NEW */}
  <li key="one">First</li>
  <li key="two">Second</li>
</ul>

// Old render
<ul>
  <li key="one">First</li>
  <li key="two">Second</li>
</ul>

// New render
<ul>
  <li key="zero">Zero</li>
  <li key="one">First</li>
  <li key="two">Second</li>
</ul>
```

With `key`s, React can clearly see:

1. The element with `key="one"` is the same `<li>` element.
2. The element with `key="two"` is the same `<li>` element.
3. A **new** element with `key="zero"` has been added at the beginning.

It can then efficiently insert only the "Zero" `<li>` element into the real DOM, without unnecessarily re-rendering "First" and "Second."

**Important Rule:** Keys must be **unique among siblings**. They don't need to be globally unique. Never use an array index as a `key` if the list items can be reordered, added, or removed. Using `index` as a key is an anti-pattern in dynamic lists because the index changes, breaking the very purpose of the `key`. Always use a stable, unique ID from your data (e.g., `item.id`).

JavaScript

```Javascript
// Bad example (if list items can change order or be filtered)
{items.map((item, index) => (
  <ListItem key={index} item={item} />
))}

// Good example
{items.map((item) => (
  <ListItem key={item.id} item={item} /> // Assuming item has a stable unique 'id'
))}
```

### C. Comparing Attributes and Props

If the element types are the same, React looks at the `props` of the old and new elements.

- React compares the `props` object of the old element with the `props` object of the new element.
- It identifies which props have changed their values.
- Only the DOM attributes corresponding to the changed props are updated on the actual DOM node.
  JavaScript

  ```Javascript
  // Initial render
  <button className="active" onClick={handleClick}>Click Me</button>

  // Next render, className changes, onClick stays the same
  <button className="inactive" onClick={handleClick}>Click Me</button>

  // React will only update the `className` attribute on the actual <button> DOM node.
  // It won't touch the onClick event listener since it hasn't changed.
  ```
